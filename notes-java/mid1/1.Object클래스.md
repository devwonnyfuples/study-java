# Object class
- 최상의 부모는 Object 이다
- 부모가 없으면 '묵시적으로' '기본적으로' Object를 상속 받고 있다
  - 컴파일러에 의해 자동으로 수행된다

## Object 최상위 부모 class 하는 이유
- 공통 기능 제공
- 다형성 기본 구현


----------------------------------------------------------------------------------------------------
# 1. 공통 기능
## 공통 기능: 1.1. toString() 
```java
    public String toString() {
        return getClass().getName() + "@" + Integer.toHexString(hashCode());
    }

    @IntrinsicCandidate
    public final native Class<?> getClass();

    @IntrinsicCandidate
    public native int hashCode();
```
### toString(): 객체 정보 제공
- 패키지를 포함한 객체의 이름
- 객체의 참조값(hashcode 16)

### toString() 사용처
- 디버깅, 로깅에 사용됨

### toString() 분석

#### 1. println()은 내부에서 기본적으로 toString()을 호출한다
```java
Object obj = new Object();
String str = new obj.toString();

System.out.println(obj);// Object.toString() 호출 출력
System.out.println(str);// toString() 반환 값 출력

// 패키지포함 이름 @ 참조값(hashcode 16진수)
java.lang.Object@a09ee92
java.lang.Object@a09ee92
```


#### 2. 객체를 재정의해서 객체의 상태를 명확하게 확인 할 수 있다
- toString() 재정의 하지 않으면 기본 toString()를 호출한다
```java

import java.util.Objects;

public class Dog {
    private String dogName;
    private int age;

    public Dog(String dogName, int age) {
        this.dogName = dogName;
        this.age = age;
    }

    @Override
    public boolean equals(Object o) {
        if (o == null || getClass() != o.getClass()) return false;
        Dog dog = (Dog) o;
        return age == dog.age && Objects.equals(dogName, dog.dogName);
    }

    @Override
    public int hashCode() {
        return Objects.hash(dogName, age);
    }

    @Override
    public String toString() {
        return "Dog{" +
                "dogName='" + dogName + '\'' +
                ", age=" + age +
                '}';
    }
}

public class testMain {
    public static void main(String[] args) {
        Dog d = new Dog("test", 1);
        Dog d2 = new Dog("test2", 2);
        Dog d3 = new Dog("test3", 3);

        System.out.println(d);// println로 객체 정보 출력
        System.out.println(d2);
        System.out.println(d3);

        User user = new User();
        System.out.println(user);// 재정의 하지 않음
    }
}

```

##### toString() 재정의 결과
```java
Dog{dogName='test', age=1}// println로 객체 정보 출력
Dog{dogName='test2', age=2}
Dog{dogName='test3', age=3}
kr.co.logintest.domain.User@659e0bfd// 재정의 하지 않음: 기본 toString() 출력
```

#### 3. OCP 원칙
- 구체에 의존하지 않는다, 추상에 의존한다
##### Open
  - 새로운 클래스를 추가해도
    - toString()을 overriding 해서 기능을 확장한다
##### Close
  - 새로운 클래스를 추가해도
    - Object를 변경하지 않는다
    - 다른 class의 toString()을 변경하지 않는다



## 공통 기능: 1.2. equals() 
: 객체가 같은지 비교
 ```java
    public boolean equals(Object obj) {
        return this == obj;
    }
 ``` 

### 1) 동일성 ==
- == 연산자를 사용
- 두 객체의 참조(주소값)이 동일한 객체를 가리키고 있는지 확인
- 완전히 같음
- 자바머신 기준
- 물리적 기준
- 메모리 참고 기준

### 2) 동등성 equals
- equals() 메서드 사용
  - Object가 제공하는 equals()는 == 으로 동일성 비교를 제공함
- 두 객체가 논리적으로 동등한지 확인
- 논리적 기준
  - 같은 가치, 같은 수준
  - 외형 다름, 외관 다름
- 무조건 재정의 해야 한다
- **기준**에 따라 달라진다
  - 객체 주소는 달라도, 회원 번호가 같으면 동등하다
  - 객체 주소는 달라도, 연락처가 같으면 동등하다
- 문자열은 == 아닌, equals() 사용한다

#### 예제) equals(), hashCode()
```java
import java.util.Objects;

public class Dog {
    private String dogName;
    private int age;

    public Dog(String dogName, int age) {
        this.dogName = dogName;
        this.age = age;
    }

    @Override
    public boolean equals(Object o) {
        // 객체 hashCode()가 같은지 체크한다
        if (o == null || getClass() != o.getClass()) return false;
        Dog dog = (Dog) o;

        // 기본형 ==로 동일성 검증, 참조형 equals()로 동일성 검증
        return age == dog.age && Objects.equals(dogName, dog.dogName);
    }

    @Override
    public int hashCode() {
        return Objects.hash(dogName, age);
    }

    @Override
    public String toString() {
        return "Dog{" +
                "dogName='" + dogName + '\'' +
                ", age=" + age +
                '}';
    }
}

// Object Class
public class Object {
    // static method
    public static int hash(Object... values) {
        return Arrays.hashCode(values);
    }

    public static boolean equals(Object a, Object b) {
        return (a == b) || (a != null && a.equals(b));
    }

    public boolean equals(Object obj) {
        return (this == obj);
    }
}

// Array Class
public class Arrays {
    // static method
    public static int hashCode(Object a[]) {
        if (a == null)
            return 0;

        int result = 1;

        for (Object element : a)
            result = 31 * result + (element == null ? 0 : element.hashCode());

        return result;
    }
}
```

### 예제) User 동일성, 동등성
```java
User a = new User("id-100");//참조 x001
User b = new User("id-100");//참조 x002
```
#### 1) 동일성 : 다르다
- a,b는 물리적으로 다르다
- a,b는 다른 메모리에 있는 객체이다

#### 2) 동등성 : 같다
- a,b는 논리적으로 같다
- a,b는 id-100 회원번호가 같다. 따라서 동등하다.

### 동일성 문제 상황 & 결과
| 상황                      | equals() | hashCode()  | 결과                                |
| ----------------------- | -------- | ----------- | --------------------------------- |
| 두 객체가 완전히 같다(동일성)            | true     | 같아야 함       | ✅ 정상                              |
| 두 객체가 다르다               | false    | 달라야 함 (이상적) | ✅ 정상                              |
| 두 객체가 다르지만 hashCode가 같다 | false    | 같음          | ⚠️ 충돌(Collision) 허용은 되지만 성능 저하 가능 |
| 두 객체가 같지만 hashCode가 다름  | true     | 다름          | ❌ HashMap, HashSet에서 동작 오류        |


## 공통 기능: 1.3. hashcode()
- 컬렉션 프레임워크

## 공통 기능: 1.4. getClass() 
: 객체의 클래스 정보 제공



## 1.5. 그 외 메서드
### clone()
- 객체를 복사할 때 사용

### multi thread
- notify()
- notifyAll()
- wail()

----------------------------------------------------------------------------------------------------

# 2. 다형성
- 부모는 자식을 담을 수 있다
- 다양한 타입의 객체를 통합적으로 처리할 수 있다
- 모든 타입의 객체를 담을 수 있다
  - Object[]을 만들면, 세상의 모든 객체를 담을수 있는 배열을 만들 수 있음

### 2.1. 다형성 한계
- Object는 모든 객체의 부모라서, 모든 객체를 대상으로 다형적 참조 가능

### 2.2. overriding 불가능
- 서로 다른 객체의 메서드가 정의되어 있지 않음
- 예시: 
  - Dog.sound();
  - Cat.sount();
- Object는 최상위라, overriding 사용할 수 없음

### 2.3. down casting 필요함
- Object를 통해 전달 받은 객체를 호출하려면, 각 객체에 맞는 다운 캐스팅이 필요함
- 각 객체의 기능을 호출하려면 down casting 을 해야 한다.