# String class
- 문자를 다루는 대표적인 타입은 char, String 2가지이다.
- 기본형 아니다, 참조형이다
- 내부에서는 기본형의 배열이다
  - byte[] 배열을 사용함
    - char : 2byte 차지함
    - 숫자, 영어는 1byte를 사용한다 -> 낭비 발생 
```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence, Constable, ConstantDesc {
    
    // 문자열 보관 -> byte[] 로 보관함
    @Stable
    private final byte[] value;// java 9 이후 byte[] 사용, 이전: char[] 사용
    private final byte coder;
    private int hash; // Default to 0
    private boolean hashIsZero; // Default to false;

    // 여러 메서드 제공함
    public boolean equals(Object anObject) {
        if (this == anObject) {
            return true;
        }
        return (anObject instanceof String aString)
                && (!COMPACT_STRINGS || this.coder == aString.coder)
                && StringLatin1.equals(value, aString.value);
    }

    public boolean startsWith(String prefix, int toffset) {
        // Note: toffset might be near -1>>>1.
        if (toffset < 0 || toffset > length() - prefix.length()) {
            return false;
        }
        byte ta[] = value;
        byte pa[] = prefix.value;
        int po = 0;
        int pc = pa.length;
        byte coder = coder();
        if (coder == prefix.coder()) {
            int to = (coder == LATIN1) ? toffset : toffset << 1;
            while (po < pc) {
                if (ta[to++] != pa[po++]) {
                    return false;
                }
            }
        } else {
            if (coder == LATIN1) {  // && pcoder == UTF16
                return false;
            }
            // coder == UTF16 && pcoder == LATIN1)
            while (po < pc) {
                if (StringUTF16.getChar(ta, toffset++) != (pa[po++] & 0xff)) {
                    return false;
               }
            }
        }
        return true;
    }

    public int indexOf(int ch, int fromIndex) {
        return isLatin1() ? StringLatin1.indexOf(value, ch, fromIndex)
                          : StringUTF16.indexOf(value, ch, fromIndex);
    }
}
```

## String class -> 문자열 생성
1. 쌍따옴표 사용
- "hello"

2. 객체 생성
- new String("hello");


## String method
- length()
```java
    public int length() {
        return value.length >> coder();
    }
    byte coder() {
        return COMPACT_STRINGS ? coder : UTF16;
    }

    static final boolean COMPACT_STRINGS;

    static {
        COMPACT_STRINGS = true;
    }

    private final byte coder;
    @Native static final byte UTF16  = 1;

```
- charAt(int index)
```java
    public char charAt(int index) {
        if (isLatin1()) {
            return StringLatin1.charAt(value, index);
        } else {
            return StringUTF16.charAt(value, index);
        }
    }

    static void checkIndex(int index, int length) {
        if (index < 0 || index >= length) {
            throw new StringIndexOutOfBoundsException("index " + index + ", length " + length);
        }
    }
// 구체 class
    public static char charAt(byte[] value, int index) {
        checkIndex(index, value);
        return getChar(value, index);
    }
    public static void checkIndex(int off, byte[] val) {
        String.checkIndex(off, length(val));
    }
```
- substring(int beginIndex, int endIndex)
```java
    public String substring(int beginIndex) {
        return substring(beginIndex, length());
    }

    public String substring(int beginIndex, int endIndex) {
        int length = length();
        checkBoundsBeginEnd(beginIndex, endIndex, length);
        if (beginIndex == 0 && endIndex == length) {
            return this;
        }
        int subLen = endIndex - beginIndex;
        return isLatin1() ? StringLatin1.newString(value, beginIndex, subLen)
                          : StringUTF16.newString(value, beginIndex, subLen);
    }
```
- indexOf(String str)
```java
    public int indexOf(String str) {
        byte coder = coder();
        if (coder == str.coder()) {
            return isLatin1() ? StringLatin1.indexOf(value, str.value)
                              : StringUTF16.indexOf(value, str.value);
        }
        if (coder == LATIN1) {  // str.coder == UTF16
            return -1;
        }
        return StringUTF16.indexOfLatin1(value, str.value);
    }
```
- toLowerCase(), toUpperCase()
```java
    public String toLowerCase() {
        return toLowerCase(Locale.getDefault());
    }
    public String toLowerCase(Locale locale) {
        return isLatin1() ? StringLatin1.toLowerCase(this, value, locale)
                          : StringUTF16.toLowerCase(this, value, locale);
    }
```
- trim()
```java
    public String trim() {
        String ret = isLatin1() ? StringLatin1.trim(value)
                                : StringUTF16.trim(value);
        return ret == null ? this : ret;
    }
```
- concat(String str)
   - 특별히 + 연산을 제공함
```java
    public String concat(String str) {
        if (str.isEmpty()) {
            return this;
        }
        return StringConcatHelper.simpleConcat(this, str);
    }
```