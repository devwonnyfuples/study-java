### 서비스 지연
- JVM memory Leak
- Heap Dump
### 장애 대응
- APM
- 제니퍼?
- 시큐어 코딩??
---------------
- 참고 유튜브 : https://youtu.be/FMUpVA0Vvjw?si=DOUXvlHsw-J0MLG7
### JVM 구조
![alt text](../resources/6장/jvmStructure.png)

#### 1. Class Loader
- 바이트 코드를 읽고, 클래스 정보를 -> 메모리의 Heap/Method Area에 저장

#### 2. JVM Memory
- 실행 중인 프로그램의 정보가 올라가 있는 메모리

#### 3. Execution Engine
- 바이트 코드를 네이티브 코드로 변환
- GC를 실행하는 실행 엔진

#### JVM Memory 구조
![alt text](../resources/6장/jvmMemory1.png)
![alt text](../resources/6장/jvmMemory.png)

##### method area
- 프로그램의 클래스 구조를 메타데이터처럼 가짐
- 메서드의 코드 들을 저장

#### heap
- 가비지 컬렉터에 의해 관리 되는 영역
- 어플리케이션 실행 중에 생성되는 객체 인스턴스를 저장하는 영역

![alt text](../resources/6장/jvmHeapArea.png)

##### Young generation == minor GC
- 1) eden
    - 새롭게 생성된 객체들이 할당되는 영역
- 2) survival0
    - minor GC로부터 살아남은 객체들이 존재하는 영역
- 3) survival1

- survival0, survival1 둘 중 하나는 꼭 비어 있어야 한다.

![alt text](../resources/6장/minorGC.png)
- 새로운 객체가 계속 생성되다 보면 -> eden에 가득 차게 됨 -> Minor GC 진행됨(mark & sweep)
- Reachable : survival0 으로 이동
    - age bit : 숫자가 1로 증가 
- Unreachable : survival1 로 이동
![alt text](../resources/6장/minorGC1.png)
![alt text](../resources/6장/minorGC2.png)
![alt text](../resources/6장/minorGC3.png)

##### Old generation == major GC
![alt text](../resources/6장/promotion.png)
- 오랫동안 참조가 된 객체이구나(오래 썻네~, 아직도 쓰네?)
- age-bit 가 3이 되면 객체를 old generation으로 이동 시킨다
- 이동 시키는 것을 promotion 이라고 한다
![alt text](../resources/6장/majorGC.png)
- major GC는 minor GC 보다 오래 걸린다

#### stack
- 메서드 호출을 stack frame 이라는 block 쌓음
- 로컬 변수, 중간 연산 결과 저장함

#### pc register
- 쓰레드가 현재 실행할 stack frame의 주소를 저장

#### native method stack
- c/c++ 의 low level 코드를 실행하는 stack

---------------
### gc가 왜 필요한가?
- 프로그램이 동적으로 할당했던 메모리 영역(heap) 중 필요 없게 된 영역(어떤 변수도 가리키지 않음) 알아서 해제 시킴
- 장점
    - 메모리 누수
    - 해체된 메모리 접근
    - 해제한 메모리 또 해제
- 단점
   - gc 작업 : 순수 오버헤드
   - 개발자가 언제 gc하는지 모름

----------
----------
----------
# 가비지 컬렉터와 메모리 할당 전략
## 대상이 죽었는가?
### 참조 카운팅 알고리즘
- 해당 객체에 접근할 수 있는 방법이 하나도 없다면
- reference count가 0 이 되면 가비지 컬렉션의 대상이 된다

![alt text](../resources/6장/referenceCount.png)

#### 한계
- 순환 참조
    - 서로가 서로를 참조하고 있는데, 직접적으로 사용되는 곳은 없음
    - 사용되지 않는 영역이 정리되지 않음
    - 결국 memory leak 발생
![alt text](../resources/6장/referenceCountCircleRefProblem.png)

### 도달 가능성 분석 알고리즘

### 다시 참조 이야기로

### 메서드 영역 회수하기


----

## 가비지 컬렉션 알고리즘
### 세대 단위 컬렉션 이론

### mark & sweep
- reference counting의 Circle Reference Problem을 해결 할 수 있다
- Root 에서 해당 객체에 접근 가능한지를 해제의 기준으로 삼는다.
- Mark : Root부터 Graph 순회를 통해, 연결된 객체를 찾아냄
- Sweep : 연결이 끊어진 객체들은 지운다
- Reachable : root랑 연결된 객체
- Unreachable : root랑 연결되지 않은 객체
- 메모리 정리 후 객체가 예쁘게 정렬됨
    - Compaction : 메모리 파편화를 막음
![alt text](../resources/6장/markandsweep.png)

#### 장점
- 순환 참조 객체를 없앨 수 있음
#### 단점
- 의도적으로 GC를 실행 시켜야 한다
   - 어느 순간 실행 중인 어플리케이션이 GC에게 컴퓨터 resource를 양보 해야 한다
- 어플리케이션 실행 && GC 실행이 병행된다
   - 어플리케이션의 사용성을 유지하면서 효율적이게 GC를 실행하는 것이 꽤나 어려운 최적화 작업이다.
   - Stop The World
   - GC를 실행하기 위해 JVM이 app 실행을 멈추는 것

#### JVM의 Root Space 어디인가?
![alt text](../resources/6장/jvmRootSpace.png)
- jvm 메모리
    - 1) stack : 로컬 변수
    - 2) method area : static 변수
    - 3) native method stack : c/c++로 작성된 JNI 참조
### mark & copy


### mark & compact


----
## 핫스팟 알고리즘 상세 구현
### 루트 노드 열거


### 안전 지점


### 안전 지역


### 기억 집합, 카드 테이블


### 쓰기 장벽


### 동시 접근 가능성 분석

---

## 클래식 가비지 컬렉터
### 시리얼 컬렉터
![alt text](../resources/6장/serialGC.png)
- 하나의 thread로 GC를 실행
    - Stop The World 시간이 길다
- single thread 환경 및 Heap 이 매우 작을때만 사용한다

### 파뉴 컬렉터


### 패러렐 스캐빈지 컬렉터
![alt text](../resources/6장/parallelGC.png)
- 여러 thread 로 GC 실행
    - Stop THe World 시간이 SerialGC 보다 짧아짐
- 멀티 코어 환경에서 app 처리 속도를 향상시키기 위해 사용됨
- java 8에서 기본으로 쓰이는 GC



### 시리얼 올드 컬렉터


### 패러렐 올드 컬렉터


### CMS 컬렉터
- Concurrent-Mark-Sweep
![alt text](../resources/6장/CMSGC.png)
- Stop The World 최소화를 위해 고안
- GC 작업 && application 동시에 실행
- G1 GC 등장으로.. 사라짐

#### 단점
- 메모리, CPU를 많이 사용함
    - mark & sweep 과정 이후, 메모리 파편화 해결하는 Compaction이 기본으로 제공되지 않음


### G1 컬렉터(가비지 우선 컬렉터)
- Garbae First == 가비지 우선
- GC 가 일어날 때, 전체 영역(Eden, Survival, Old generation)을 탐색하지 않는다.

![alt text](../resources/6장/G1GC.png)
- heap을 일정 크기의 region 나눔
    - Young Generation
    - Old Generation
- Runtime에 G1 GC가 필요해져서
    - 영역별 Region 개수를 튜닝한다
    - Stop The World를 최소화 시킴
- java 9 이상부터, 기본 GC 실행 방식


### 오늘날 가비지 컬렉터들

------

## 저지연 가비지 컬렉터
### 셰넌도어


### ZGC


### 세대 구분 ZGC

------

## 적합한 가비지 컬렉터 선택하기
### 앱실론 컬렉터


### 컬렌터들 간 비교 및 취사 선택


### 가상 머신과 가비지 컬렉터 로그


### 가비지 컬렉터 매개 변수 정리

----------
## 실전: 메모리 할당, 회수 전략

### 객체는 먼저 에덴에 할당된다


### 큰 객체는 곧바로 구세대에 할당된다


### 나이가 차면 구세대로 옮겨진다


### 공간이 비좁으면 강제로 승격 시킨다

---------
### StringBuilder
![alt text](../resources/6장/gcLessSituation.png)

![alt text](../resources/6장/gcLessSituation1.png)

![alt text](../resources/6장/gcLessSituation3.png)

### static 변수 : GC
![alt text](../resources/6장/staticVariable.png)
- java 7 까지는 관리 대상이 맞음